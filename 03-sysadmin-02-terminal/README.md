# Домашнее задание к занятию "3.2. Работа в терминале. Лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей, если считаете, что она могла бы быть другого типа.  
  ``type cd`` => cd - builtin команда. Если бы она была не встроенной, то не могла бы изменить рабочую директорию текущего процесса shell, только могла бы изменить рабочую директорию нового процесса, что нам не нужно.  


2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?  
`grep -c <some_string> <some_file>`


3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?  
``ps -p 1`` => systemd


4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?  
``ls some_none_exists 2>/dev/pts/2``  


5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.  
``cat < test.txt > test_new.txt``


6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?  
Да, получится, например `echo some > /dev/tty1`. Выводимые данные наблюдаются. Псевдотерминалы для этого и были созданы.


7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?  
``bash 5>&1`` создаст поток ввода-вывода с ассоциированным файловым дескриптором с номером 5 и перенаправит его на stdout текущего TTY. Команда `echo netology > /proc/$$/fd/5` выведет `netology`, потому что мы перенаправили stdout команды echo в файловый дескриптор с номером 5, а он ранее был перенаправлен на stdout текущего терминала. 


8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty?  
Да, надо использовать конструкцию N>&1 1>&2 2>&N, где N - новый промежуточный дескриптор:  ``ls some_none_exists . 3>&1 1>&2 2>&3 | wc -l``

 
9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?  
Команда выведет все переменные окружения для текущего процесса bash. Аналогичный вывод можно получить командой ``printenv``

 
10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.  
184 строка man proc: /proc/[pid]/cmdline - readonly файл, содержащий полную строку запуска процесса, если он не зомби;
230 строка man proc: /proc/[pid]/exe - символическая ссылка, содержащая полное имя пути выполняемой команды


11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.  
``cat /proc/cpuinfo`` => flags => sse4_2


12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty.  
	Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2.  
	Однако:

    ```bash
	   vagrant@netology1:~$ ssh localhost 'tty'
	   not a tty
    ```

	Почитайте, почему так происходит, и как изменить поведение.   
pty не выделяется, так как мы передаем команду как параметр для ssh. Для того, чтобы выделился pty, необходимо использовать параметр ``-t`` : ``ssh -t localhost 'tty'`` 


13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.  
Чтобы reptyr заработал, изменил /proc/sys/kernel/yama/ptrace_scope. Потом получилось.


14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте? что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.  
tee - дублирует поток stdin в stdout и file. `echo string | sudo tee /root/new_file` будет работать, потому что tee запустится с правами root.





