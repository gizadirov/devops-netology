# Домашнее задание к занятию 4. «PostgreSQL»## Задача 1Используя Docker, поднимите инстанс PostgreSQL (версию 13). Данные БД сохраните в volume.Подключитесь к БД PostgreSQL, используя `psql`.Воспользуйтесь командой `\?` для вывода подсказки по имеющимся в `psql` управляющим командам.**Найдите и приведите** управляющие команды для:- вывода списка БД,- подключения к БД,- вывода списка таблиц,- вывода описания содержимого таблиц,- выхода из psql.## Ответ- \l[+]  - вывод списка БД,- \c     - подключение к БД,- \d[S+] - вывод списка таблиц,-  \d[S+]  NAME - вывода описания содержимого таблиц,- \q - выход из psql.## Задача 2Используя `psql`, создайте БД `test_database`.Изучите [бэкап БД](https://github.com/netology-code/virt-homeworks/tree/virt-11/06-db-04-postgresql/test_data).Восстановите бэкап БД в `test_database`.Перейдите в управляющую консоль `psql` внутри контейнера.Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.Используя таблицу [pg_stats](https://postgrespro.ru/docs/postgresql/12/view-pg-stats), найдите столбец таблицы `orders` с наибольшим средним значением размера элементов в байтах.**Приведите в ответе** команду, которую вы использовали для вычисления, и полученный результат.## Ответ```docker compose exec postgres psql -U postgres -c "CREATE DATABASE test_database"docker compose exec postgres bash -c "psql -U postgres -d test_database < /test_data/test_dump.sql"docker compose exec postgres psql -U postgrespostgres=# \c test_databaseYou are now connected to database "test_database" as user "postgres".test_database=# ANALYZE VERBOSE orders;INFO:  analyzing "public.orders"INFO:  "orders": scanned 1 of 1 pages, containing 8 live rows and 0 dead rows; 8 rows in sample, 8 estimated total rowsANALYZEtest_database=# SELECT attname, avg_width FROM pg_stats WHERE tablename='orders' ORDER BY avg_width desc LIMIT 1; attname | avg_width---------+----------- title   |        16(1 row)```## Задача 3Архитектор и администратор БД выяснили, что ваша таблица orders разрослась до невиданных размеров ипоиск по ней занимает долгое время. Вам как успешному выпускнику курсов DevOps в Нетологии предложилипровести разбиение таблицы на 2: шардировать на orders_1 - price>499 и orders_2 - price<=499.Предложите SQL-транзакцию для проведения этой операции.Можно ли было изначально исключить ручное разбиение при проектировании таблицы orders?## Ответ```commandlineBEGIN;ALTER TABLE orders RENAME TO orders_tmp;CREATE TABLE orders AS table orders_tmp WITH NO DATA;CREATE TABLE orders_1 (    CHECK (price > 499)) INHERITS (orders);CREATE TABLE orders_2 (    CHECK (price <= 499)) INHERITS (orders);CREATE RULE orders_1_ins ASON INSERT TO orders WHERE    (price > 499)DO INSTEAD    INSERT INTO orders_1 VALUES (NEW.*);       CREATE RULE orders_2_ins ASON INSERT TO orders WHERE    (price <= 499)DO INSTEAD    INSERT INTO orders_2 VALUES (NEW.*);    INSERT INTO ordersSELECT * FROM orders_tmp;DROP TABLE orders_tmp;COMMIT;```Первоначально шардинг можно было настроить так:```commandlineCREATE TABLE orders (    id integer NOT NULL,    title character varying(80) NOT NULL,    price integer DEFAULT 0) PARTITION BY RANGE (price);CREATE TABLE orders_1 PARTITION OF orders    FOR VALUES GREATER THAN ('499');CREATE TABLE orders_2 PARTITION OF orders    FOR VALUES FROM ('0') TO ('499')```## Задача 4Используя утилиту `pg_dump`, создайте бекап БД `test_database`.Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца `title` для таблиц `test_database`?## Ответ```commandlinedocker compose exec postgres bash -c "pg_dump -U postgres test_database > /test_data/test_database_dump.sql"```Нужно добавить констрейнт UNIQUE на поле title:```CREATE TABLE public.orders (    id integer,    title character varying(80) UNIQUE,    price integer);```